\chapter{Introduction}
\label{ch:introduction}

\dictum[Freeman Dyson]{It is better to be wrong than to be vague.}
\vskip 1em

%\begin{otherlanguage}{ngerman}
%Die ältesten Bestimmungen der wahren Grösse der Moleküle hat die kinetische
%Theorie der Gase ermöglicht, während die an Flüssigkeiten beobachteten
%physikalischen Phänomene bis jetzt zur Bestimmung der Molekülgrössen nicht
%gedient haben. \dots
%\end{otherlanguage}



% Accuracy and Metrics
The number of possible alignments grow exponentially with length. The usual
underlying question to finding ``correct'' alignments. Regarding the precision
of alignment, one is usually interested in base-to-base (aka letter-to-letter)
correspondence between the sequences, even though for some applications a less
detailed solution is sufficient: only the similarity between sequences or the
location where a read maps to a reference. Exact alignment is only useful for
very short sequences (often kmers), and for all other cases the optimized metric
may be hamming distance, edit distance (unit costs), Levenshtein distance,
affine costs, convex and concave costs, general costs and others. 

% Problem statement
Depending on the the number of aligned sequences, there is pairwise alignment
and multiple sequence alignment (MSA). Depending on the parts of the sequences
that are aligned to each other, we differentiate global, local and various
semi-global alignemnts. There are generalizations to sequence-to-sequence
alignment, including aligning to nonlinear structures, such as directed acyclic
graphs, DAGs, general graphs and others. These structures are nowadays becoming
more common as a compressed form of representing a set of references to which a
sequence can be aligned. Often, one best alignment is sufficient but finding
several best (top-K) alignments. In the context of read mapping, a set of reads
is aligned to the same reference sequence so an indexing procedure is often
useful for the performance.

We specifically consider the mapping of a set of reads to a general graph, and
the global pairwise alignment.

Existing optimal algorithms are based on dynamic programming (DP) and
run in quadratic time (assuming that the number of errors is proportional to the
length)

we employ the A* algorithm which is an \emph{informed} algorithm,