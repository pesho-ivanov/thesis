%*******************************************************
% Abstract
%*******************************************************
%\renewcommand{\abstractname}{Abstract}
\pdfbookmark[1]{Abstract}{Abstract}
\begingroup
\let\clearpage\relax
\let\cleardoublepage\relax
\let\cleardoublepage\relax

\chapter*{Abstract}
\input{\dir/abstract-english}

\endgroup

\cleardoublepage%

\begingroup
\let\clearpage\relax
\let\cleardoublepage\relax
\let\cleardoublepage\relax

%\begin{otherlanguage}{ngerman}
\pdfbookmark[1]{Zusammenfassung}{Zusammenfassung}
\chapter*{Zusammenfassung}

\input{\dir/abstract-german}

Sequenzalignment ist der Prozess der Erkennung von Ähnlichkeiten zwischen
Sequenzen. Seit vor einem halben Jahrhundert zum ersten Mal genetische Sequenzen
sequenziert wurden, ment ist eine grundlegende Aufgabe in der Molekularbiologie
mit Anwendungen in der Evolutionsbiologie, Genomassemblierung,
Variationserkennung und andere. Ein laufender Übergang von uns- Die Umstellung
von Genomen auf die Verwendung von Pangenomen motiviert zum Überdenken der
klassischen Ausrichtung Algorithmen. Die Vielfalt der Anwendungen kombiniert mit
der wachsenden Menge an genetische Daten motivieren die Entwicklung schneller
und genauer Ausrichtungsalgorithmen.

Existierende Ausrichtungsalgorithmen sind entweder optimal, aber quadratisch
oder schnell, aber geeignet. nahe. Diese Arbeit prosiert einen eleganten Ansatz
zur Ausrichtung basierend auf dem \A Algorithmus, der sowohl heuristisch schnell
als auch nachweislich optimal ist. Es wurde gezeigt Diese Ausrichtung ist in
stark subquadratischer Zeit im Allgemeinen wahrscheinlich nicht lösbar Fall. Das
Ziel, das wir in dieser Arbeit verfolgen, ist die Anwendung des \A Ansatz als
möglichst viele Arten von Daten und bleibt dabei schnell und optimal. Wir
betrachten zwei Arten von Alignment: semi-global, um einen DNA-Satz zu kartieren
Sequenzen zu einer Pangenom-Referenz; und global zur Berechnung der
Bearbeitungsentfernung

Abstand zwischen zwei Folgen. Um verschiedene Datendimensionen handhaben zu
können, verwenden wir schlagen mehrere Techniken vor und untersuchen empirisch
ihre Laufzeitskalierung: ein Versuch Index ermöglicht sublineare Skalierung mit
der Referenzgröße, Seed-Heuristik ermöglicht nahezu lineare Skalierung mit
Sequenzlänge und ungenaue Seed-Matching und Match-Verkettung Skalierung auf hohe
Fehlerraten ermöglichen. Aufgrund der überlegenen Skalierung des \A sich nähern,
Unsere prototypischen Implementierungen laufen um Größenordnungen schneller als
bestehende optimale Anflüge auch bei langen Fehlsequenzen.

Wir sehen eine Vielzahl zukünftiger Richtungen für die Weiterentwicklung von \A
für Sequenz Ausrichtung, einschließlich anderer Ausrichtungsarten,
Verallgemeinerung der Bearbeitungsentfernungsmetrik, Lockerung der
Optimalitätsgarantie, theoretische Analysen der Leistung und Effizientere
Implementierungen für den Produktionseinsatz.
%\end{otherlanguage}

\endgroup
\vfill

% Problem
%Biological sequences do not generally
%align perfectly due to biological differences and technical errors. Given two
%sequences, the desired alignment is a position-to-position correspondence
%between two sequences which minimizes the edit costs (substitutions, insertions
%or deletions).
%This task is closely related to calculating \emph{edit distance}.

% Existing algorithms
% by using heuristic
%information to speed up the alignment without sacrificing correctness.
%to to making it both heuristically fast and provably optimal. 

%Can we use the \A algorithm to find provably optimal alignment heuristically
%fast?

%Practical alignment algorithms are desired to \textcircled{1} find accurate
%alignments, \textcircled{2} apply to a wide range of data, and \textcircled{3}
%use little time and memory.

% Shortest path formulation
%We consider a principled alignment formulation based on shortest paths and
%demonstrate that the \A shortest path algorithm can be used to outperform
%current methods. Unlike existing methods, \A enables an \emph{informed search}
%based on information from the unaligned sequence suffixes, thus radically

%Runtime, memory usage, scaling. Data variation A good algorithm should be
%optimal, complete, performant (fast and low on memory)

%polynomial speed ups on real data. It \textcircled{1} provides optimality
%guarantees according to edit distance, \textcircled{2} scales to long and noisy
%sequences, and \textcircled{3} scales subquadratically with sequence length.

%To scale to large reference sequences, we extend the graph with a trie index. To
%scale to long queries, we introduce design an admissible \emph{seed heuristic},
%which is provably-optimal also efficient to compute. To scale to high error
%rates, we design  

%improving the empyrical runtime scaling (up to linear) in the average case while
%providing optimality guarantees.

%mapping on pangenomes, graph references, 