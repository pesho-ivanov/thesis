\subsection{Setup} \label{sec:evals-setup}

\paragraph{Synthetic data}
Our synthetic datasets are parameterized by sequence length~$n$, induced error
rate~$e$, and total number of basepairs~$N$, resulting in $N/n$ sequence pairs.
The first sequence in each pair is uniform-random from~$\Sigma^n$. The second is
generated by sequentially applying~$\lfloor e{\cdot} n\rfloor$ edit operations
(insertions, deletions, and substitutions with equal~$1/3$ probability) to the
first sequence. Introduced errors can cancel each other, making the
\emph{divergence}~$d$ between the sequences less than~$e$. Induced error rates
of $1\%$, $5\%$, $10\%$, and~$15\%$ correspond to divergences of $0.9\%$,
$4.3\%$, $8.2\%$, and~$11.7\%$, which we refer to as $1\%$, $4\%$, $8\%$,
and~$12\%$.

\paragraph{Human data}
We use two datasets%
of ultra-long Oxford Nanopore Technologies (ONT) reads of the human genome: one
without and one with genetic variation. All reads are $500\mbox{--}1100\kbp$
long, with mean divergence around $7\%$. The average length of the longest gap
in the alignment is
$0.1\kbp$ for ONT reads, and $2\kbp$ for ONT reads with genetic
variation~(detailed statistics in~\cref{tab:hg}).
The reference genome is
CHM13~(v1.1)~\citep{nurk2022complete}. The reads used for each dataset are:

\begin{itemize}
  \item \emph{ONT}: $50$ reads sampled from those used to assemble
        CHM13.
  \item \emph{ONT with genetic variation}: $48$~reads from another
        human~\citep{bowden2019sequencing}, as used in the \wfa
        paper~\citep{marco2022optimal}.
\end{itemize}

\paragraph{Algorithms and aligners}
We compare \SH, \CSH, and \GCH as implemented in \astarpa%
to the state-of-the-art exact aligners \wfa and \edlib. We also compare to
\dijkstra and to variants without pruning, and without diagonal transition. We
exclude \seqan and \parasail since they are outperformed by \wfa and
\edlib~\citep{marco2021fast}.

\paragraph{\astarpa parameters}
We run all aligners with unit edit costs with traceback enabled, returning an
alignment. In \astarpa we fix $r{=}2$ (inexact matches) and seed length
$k{=}15$. Both are a trade-off: inexact matches and lower $k$ increase the
heuristic potential to efficiently handle more divergent sequences, while too
low $k$ gives too many matches.

\paragraph{Execution}
We use
\pabench
on Arch Linux on an \texttt{Intel Core i7-10750H} processor with $\qty{64}{GB}$
of memory and $6$ cores, without hyper-threading, frequency boost, and CPU power saving
features. We fix the CPU frequency to \texttt{2.6GHz}, limit the memory usage to
$\qty{32}{GiB}$, and run $1$ single-threaded job at a time with niceness $-20$.

\paragraph{Measurements}
\pabench first reads the dataset from disk and then measures the wall-clock time
and increase in memory usage of each aligner. Plots and tables refer to the
average alignment time per aligned pair. Best-fit polynomials are calculated via
a linear fit in the log-log domain using the least squares method.

