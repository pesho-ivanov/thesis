\section*{Related work}
\addcontentsline{toc}{section}{\protect\numberline{}{Related work}}

There have been many solutions to alignment~\citep{navarro2001guided}. With the
increasing quantity of genomic data, the need for fast and accurate algorithms
has been steadily increasing~\cite{alser2021technology}. There are multiple
directions in which the sequence alignment algorithms are being developed:
developing scalable algorithms, generalizing the optimization metric, emplying
heuristics for approximate solutions, adapting existing algorithms to novel
types of data, exploiting parallelizing hardware, implementing fast and
memory-efficient tools (aligners). This thesis focuses on algorithmic approaches
to sequence alignment so here outline the main existing optimal algorithms, some
practical but suboptimal heuristics, and the \A shortest path algorithm which is
the framework for our provably optimal and heuristically fast algorithm.

\paragraph{Approaches to sequence alignment}

\paragraph{Dynamic programming for global alignment}
The first efficient solution for global alignment, known as the Needleman-Wunsch
algorithm, got developed around~\citeyear{vintsyuk1968speech}~
\cite{vintsyuk1968speech,needleman1970general}. This algorithm is based on the
dynamic programming~(DP) technique~\cite{bellman1954theory} of splitting a task
into overlapping subtasks~(or \emph{states}) each of which can be solved once
and then being reused. Each node of the alignment graph (aligning a prefix of
the first sequence to a prefix of the second sequence) is a state in the DP.
Each subtask can be solved by reducing it to already solved alignments of
shorter prefixes, and extending them by a last operation of matching or
mismatching the last letters from the prefixes, inserting one, or inserting the
other (equivalent to deleting from the first sequence). Each subtask is solved
for $\Oh(1)$ so the quadratic number of prefix pairs is solved for quadratic
overall time, even though the number of possible alignments is exponential.
Independently, it was applied to compute edit distance for biological
sequences~\citep{needleman1970general,sankoff1972matching,sellers1974theory,wagner1974string}.
This well-known algorithm is implemented in modern aligners  like
\seqan~\citep{reinert2017seqan} and \parasail~\citep{daily2016parasail}.
Improving the performance of these quadratic algorithms has been a central goal
in later works.

\paragraph{Dynamic programming for semi-global alignment}
Semi-global alignment is a related problem to global alignment but in addition
to the need to align letter-to-letter, it also requires determining a starting
position in the reference. This task has also been efficiently solved using a
similar DP approach~\cite{sellers1980theory,smith1981identification} taking
$\Oh(nm)$ to align a single query of length $n$ to a reference of length $m$. It
is highly redundant to explore the whole reference for each alignment, so
various data structures were suggested that can be precomputed to index the
reference, and then reuse this index to quickly align multiple query sequences
~\citeyear{pearson1988improved}~\cite{pearson1988improved} and has become
central to read alignment of high-throughput sequencing.

% Optimal DP-based approaches
\paragraph{Optimal alignment}
Current optimal alignment algorithms reach the impractical $\Oh(nm)$ runtime
that has been shown to be a lower bound for the worst-case edit distance
computation~\cite{backurs2015edit}. In this light, approaches for improving the
efficiency of optimal alignment have taken advantage of specialized features of
modern CPUs to improve the practical runtime of the Smith-Waterman dynamic
programming (DP) algorithm~\cite{smith_comparison_1981} considering all possible
starting nodes. These use modern SIMD instructions (\AG
\vg~\cite{garrison_variation_2018} and \pasgal~\cite{jain_accelerating_2019}) or
reformulations of edit distance computation to allow for bit-parallel
computations in \graphaligner \footnote{We refer as \bitparallel to to the
bit-parallel DP algorithm implemented in \graphaligner tool
\cite{rautiainen_bitparallel_2019}.}~\cite{rautiainen_bitparallel_2019}. Many of
these, however, are designed only for specific types of genome graphs, such as
{\itshape de Bruijn}
graphs~\cite{liu_debga_2016,limasset2019toward} and
variation graphs~\cite{garrison_variation_2018}. A compromise often made when
aligning sequences to cyclic graphs using algorithms reliant on directed acyclic
graphs involves the computationally expensive ``DAG-ification'' of graph
regions~\cite{kavya_sequence_2019,garrison_variation_2018}.

\paragraph{Suboptimal heuristic algorithms}
On the other hand all optimal solutions are near-quadratic and the theoretical
limit is near-quadratic. To spead up beyond this near-quadratic barrier, current
practical algorithms break the optimality guarantee hoping that the produced
alignments are accurate enough. 

% Heuristics for alignment
Both for sequence-to-sequence alignment and sequence-to-graph alignment,
heuristics are employed to keep alignment
tractable~\cite{altschul_basic_1990,langmead_fast_2012,garrison_variation_2018},
especially for large populations of human-sized genomes.
%
%
In the last decades, approximate and alignment-free methods satisfied the demand
for faster algorithms which process huge volumes of genomic
data~\citep{kucherov2019evolution}. 
%
\emph{Seed-and-extend} is arguably the most popular paradigm in read
alignment~\citep{altschul_basic_1990,langmead_fast_2012,li_fast_2009}. First,
substrings (called \emph{seeds} or \emph{kmers}) of the read are extracted, then
aligned to the reference, and finally prospective matching locations are
\emph{extended} on both sides to align the full read.

While such a heuristic may produce acceptable alignments in many cases, it
fundamentally does not provide quality guarantees, resulting in suboptimal
alignment accuracy.

\paragraph{Seed-and-extend}
Since optimal alignment is often intractable, many aligners use heuristics, most
commonly the \emph{seed-and-extend}
paradigm~\cite{altschul_basic_1990,langmead_fast_2012,li_fast_2009}. In this
approach, alignment initiation sites (\emph{seeds}) are determined, which are
then \emph{extended} to form the \emph{alignments} of the query sequence. The
fundamental issue with this approach, however, is that the seeding and extension
phases are mostly decoupled during alignment. Thus, an algorithm with a provably
optimal extension phase may not result in optimal alignments due to the
selection of a suboptimal seed in the first phase. In cases of high sequence
variability, the seeding phase may even fail to find an appropriate seed from
which to extend.

\paragraph{\A for sequence alignment}
There has been one attempt to apply \A for optimal pairwise
alignment~\cite{dox2018efficient} which uses a heuristic function that accounts
only for the length of the remaining query sequence to be aligned. However, it
does not significantly outperform \dijkstra (in fact, it is equivalent for a
zero matching cost).
% TODO: MSA
Informed search for sequence alignment

\paragraph{Known limitations}

Quadratic optimal for semi-global

In its general case, it is not solvable for strictly subquadratic time which is
often prohibitively slow. Faster approximate algorithms are instead used in
practice.

We employ the \A informed search algorithm in order to design an
optimal algorithm that scales subquadratically for related sequences.

\paragraph{Graph references}
First attempts to include variation into the reference data structure were made
by augmenting the local alignment method to consider alternative walks during the
extend step~\cite{schneeberger_simultaneous_2009,palmapper}. This approach has
since been extended from the linear reference case to graph references. To
represent non-reference variation of multiple references during the seeding
stage, HISAT2 uses generalized compressed suffix
arrays~\cite{siren_indexing_2014} to index walks in an augmented reference
sequence, forming a local genome graph~\cite{kim_graphbased_2019}.
VG~\cite{garrison_variation_2018} uses a similar
technique~\cite{siren_indexing_2017} to index variation graphs representing a
population of references.