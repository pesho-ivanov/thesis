\graphicspath{{\dir/}}

%keywords: Next-generation sequencing, Genome graph, Edit distance, Semi-global
%alignment, Global alignment, Long reads, Optimal alignment, Shortest path, \A
%algorithm, Seed heuristic

\chapter{Introduction} \label{ch:introduction}

\paragraph{Motivation}
Sequence alignment has been a core problem in computational biology for the last
half-century. It is an open problem whether exact pairwise alignment is possible
in linear time for related sequences~\citep{medvedev2022theoretical}.

An algorithm without an objective function may be wrong because they do not
solve the correct problem. or because they 

Algorithms that guarantee correctness can be wrong only by being given a wrong problem.

An approximate algorithm can be wrong either because it did not fullfill its
mathematical goal. reach its solve the problem because of either optimizing the
\emph{wrong} function.

Algorithm correctness is arguably a useful property which is often not simple to
guarantee. It can undoubtedly improve accuracy, especially in the case of
complex data, but still be wrong from biological point of view. This is because
of  This Nevertheless, since biology is a natural science, its  optimality
guarantees must have an additional impact on the development of the field. It
not only but allows to enjoy being wrong rather than vague. Moreove, often
problems in computational biology are ill-stated andalgorithms that approximate
algorithms that. But many algorithms in computational biology do not even have a
formal statement 

% Our scope
Formally, we consider the optimal \emph{sequence-to-graph alignment} problem,
the task of finding an optimal base-to-base correspondence between a query
sequence and a (possibly cyclic) walk in the graph. Related alignment problems
have already been formulated as graph shortest path
problems~\cite{jain_complexity_2019}.

\section{Motivation}

Observation 1: A long query has more information that may hint towards the best
mapping place. Unlike the practical approximate algorithms, the existing optimal
algorithm do not exploit this information. As a result, all state-of-the-art
optimal algorithms take longer to map a longer query to a reference. 

Observation 2: The input is linear, the output is linear, the best case is
linear. On the other hand all optimal solutions are near-quadratic and the
theoretical limit is near-quadratic. To spead up beyond this near-quadratic
barrier, current practical algorithms break the optimality guarantee hoping that
the produced alignments are accurate enough. 

%But it is possible to be fast and accurate in the same time?
We take another approach: we preserve the optimality guarantee and use
substantially more information with the hope to be fast enough. As it turns out,
when the error rate is limited, our optimal solutions empirically scale
near-linearly up to very long sequences. This translates to many orders of
magnitude of runtime speedup compared to state-of-the-art optimal aligners.

% Problem, applications
The problem of aligning one biological sequence to another has been formulated
over half a century ago~\citep{needleman1970general} and is known as
\emph{global pairwise alignment}~\citep{navarro2001guided}. Pairwise alignment
has numerous applications in computational biology, such as genome assembly,
read mapping, variant detection, multiple sequence alignment, and differential
expression~\citep{prjibelski2018sequence}. Despite the centrality and age of
pairwise alignment, ``a major open problem is to implement an algorithm with linear-like
empirical scaling on inputs where the edit distance is linear
in~$n$''~\citep{medvedev2022theoretical}.

% Near-quadratic worst case
Alignment accuracy affects the subsequent analyses, so a common goal
is to find a shortest sequence of edit operations (insertions, deletions, and
substitutions of single letters) that transforms one sequence into the other.
Finding such a sequence of operations is at least as hard as computing the \emph{edit
distance}, which has recently been proven to not be computable in strongly
subquadratic time, unless SETH is false~\citep{backurs2015edit}. Given that
the number of sequencing errors is proportional to the length, existing exact aligners are
limited by quadratic scaling not only in the worst case but also in practice.
This is a computational bottleneck given the growing amounts of biological data
and the increasing sequence lengths~\citep{kucherov2019evolution}.

%\subsection{Knowledge gap}
%\dictum{%
%   Provably optimal and heuristically fast.}
%\vskip 1em

Sequence alignment is a class of combinatorial problems that is of primary
importance for analysis of genetic data. Algorithms and tools for alignment have
been thoroughly developed and routinely used for genome assembly, RNA
quantification, detecting splicing, oncology, multiple sequence alignment (MSA),
and evolutionary biology. Types of sequence alignment include global alignment,
semi-global alignment, mapping, local alignment, and others. For each type, a
common tradeoff that had to be done is between the alignment accuracy and the
performance to find it.

% graph reference
An additional difficulty is the fact that in the
upcoming pangenomic era, these algorithms must be also applicable to complex
graph structures. For more than 60 years, a linear sequence has been extremely
useful as a representation of a single genome. The affordability of sequencing
technologies enables not only to sequence genomes deeper but also to sequence
many genomes (e.g. of organisms or single cells), building a pangenome (an
abstracted genome that represents the genetic variation of a whole clade). The
shift towards population studies in the last decade motivates the adoption of
graph data structures which serve as compressed representations of collections
of related genomes (genomes are paths in the graph).

% \A context 
An optimal alignment can naturally be represented as a shortest path in an
alignment graph (equivalent to the DP table). In order to find such a shortest
path with minimal exploration, we instantiate the \A algorithm with a novel
heuristic function based on the unaligned parts of the sequences. This
additional information is a problem-specific heuristic function and it heavily
determines the efficiency of the search. For any explored state by \A, this
heuristic function should compute a lower bound on the remaining path length, or
more specifically, the minimal cost of edit operations needed to align the
remaining sequences.

\paragraph{Main contributions}
We have effectively applied the \A algorithm to optimal sequence alignment. We
demontrated that the additional information from the whole sequence can improve
the scaling with query length, reference size and error rate, substantially
decrease the necessary computations, and result in algorithms that are orders of
magnitude faster than existing optimal algorithms. We apply the \A approach to
two types of alignment: semi-global (mapping) and global.


% from seeds paper

% General: aligning, edit distance
Alignment of reads to a reference genome is an essential and early step in most
bioinformatics pipelines. While linear references have been used traditionally,
an increasing interest is directed towards graph references capable of
representing biological variation~\citep{garrison_variation_2018}.
%
Specifically, a \emph{sequence-to-graph} alignment is a base-to-base
correspondence between a given read and a walk in the graph. As sequencing
errors and biological variation result in inexact read alignments, edit distance
is the most common metric that alignment algorithms optimize in order to find
the most probable read origin in the reference.

% We note that in contrast to linear references, reference graphs capture
% genomic variation and therefore enable more accurate
% alignments~\citep{garrison_variation_2018}.

\paragraph{Suboptimal alignment}
%
In the last decades, approximate and alignment-free methods satisfied the demand
for faster algorithms which process huge volumes of genetic
data~\citep{kucherov2019evolution}. 
%
\emph{Seed-and-extend} is arguably the most popular paradigm in read
alignment~\citep{altschul_basic_1990,langmead_fast_2012,li_fast_2009}. First,
substrings (called \emph{seeds} or \emph{kmers}) of the read are extracted, then
aligned to the reference, and finally prospective matching locations are
\emph{extended} on both sides to align the full read.

While such a heuristic may produce acceptable alignments in many cases, it
fundamentally does not provide quality guarantees, resulting in suboptimal
alignment accuracy.
%
In contrast, here we demonstrate that seeds can benefit optimal alignment as
well.

\paragraph{Key challenges in optimal alignment}
%
Finding optimal alignments is desirable but expensive in the worst case,
requiring $\Oh(Nm)$ time~\citep{equi2019complexity}, for graph size $N$ and read
length $m$.
%
Unfortunately, most optimal sequence-to-graph aligners rely on dynamic
programming (DP) and always reach this worst-case asymptotic runtime. Such
aligners include \vargas~\citep{darby2020vargas},
\pasgal~\citep{jain_accelerating_2019},
\graphaligner~\citep{rautiainen_bitparallel_2019},
\hga~\citep{feng2021accelerating}, and \vg~\citep{garrison_variation_2018},
which use bit-level optimizations and parallelization to increase their
throughput.

In contrast, we follow the promising direction of using a heuristic to avoid
worst-case runtime on realistic data. To this end, \astarix rephrases the task
of alignment as a shortest-path problem in an \emph{alignment graph} extended by
a \emph{trie index}, and solves it using the \A~algorithm instantiated with a
problem-specific \prefixh. Importantly, its choice of heuristic only affects
performance, not optimality.
%
Unlike DP-based algorithms, this \prefixh allows scaling sublinearly with the
reference size, substantially increasing performance on large genomes. However,
it can only efficiently align reads of limited length.

%only optimal alignment in this thesis
%asymptotics analysis
%????? linear I/O but quadratic optimal

\input{\dir/prelims}
\input{\dir/progress}
\input{\dir/problem}
\input{\dir/contributions}
