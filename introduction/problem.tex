\section{Research goals and scope}

% Our scope
Formally, we consider the optimal \emph{sequence-to-graph alignment} problem,
the task of finding an optimal base-to-base correspondence between a query
sequence and a (possibly cyclic) walk in the graph. Related alignment problems
have already been formulated as graph shortest path
problems~\cite{jain_complexity_2019}.

%\paragraph{Problem statement}
%\paragraph{Problem domain}

\subsection{Semi-global alignment}

% General: aligning, edit distance
Alignment of reads to a reference genome is an essential and early step in most
bioinformatics pipelines. While linear references have been used traditionally,
an increasing interest is directed towards graph references capable of
representing biological variation~\citep{garrison_variation_2018}.
%
Specifically, a \emph{sequence-to-graph} alignment is a base-to-base
correspondence between a given read and a walk in the graph. As sequencing
errors and biological variation result in inexact read alignments, edit distance
is the most common metric that alignment algorithms optimize in order to find
the most probable read origin in the reference.

% We note that in contrast to linear references, reference graphs capture
% genomic variation and therefore enable more accurate
% alignments~\citep{garrison_variation_2018}.

%\begin{floatingfigure}[l]{0.5\textwidth}
\begin{figure}[t]
    \includegraphics[width=0.5\textwidth]{alignment-types}
	\caption[Alignment types]{Alignment types.}
    \label{fig:alignment-types}
\end{figure}

% paper-trie; seed-and-extend approach to semi-global alignment
\paragraph{Seed-and-Extend}
Since optimal alignment is often intractable, many aligners use heuristics, most
commonly the \emph{seed-and-extend}
paradigm~\cite{altschul_basic_1990,langmead_fast_2012,li_fast_2009}. In this
approach, alignment initiation sites (\emph{seeds}) are determined, which are
then \emph{extended} to form the \emph{alignments} of the query sequence. The
fundamental issue with this approach, however, is that the seeding and extension
phases are mostly decoupled during alignment. Thus, an algorithm with a provably
optimal extension phase may not result in optimal alignments due to the
selection of a suboptimal seed in the first phase. In cases of high sequence
variability, the seeding phase may even fail to find an appropriate seed from
which to extend.

\subsection{Pangenomes and reference graphs}

The shortest path approach naturally fits more complex references than linear.
In fact, any graph reference (incl. cycles) is fine.

% paper-trie; Accounting for variation
%\paragraph{Accounting for Variation}
First attempts to include variation into the reference data structure were made
by augmenting the local alignment method to consider alternative walks during the
extend step~\cite{schneeberger_simultaneous_2009,palmapper}. This approach has
since been extended from the linear reference case to graph references. To
represent non-reference variation of multiple references during the seeding
stage, HISAT2 uses generalized compressed suffix
arrays~\cite{siren_indexing_2014} to index walks in an augmented reference
sequence, forming a local genome graph~\cite{kim_graphbased_2019}.
VG~\cite{garrison_variation_2018} uses a similar
technique~\cite{siren_indexing_2017} to index variation graphs representing a
population of references.

% paper-trie; The benefit from genome graphs
Historically, a single linear reference sequence has been used to represent the
most common variants in a population. While providing a working abstraction for
most cases, rare or sub-population specific variation is especially hard to
model in this setting, creating a reference allele
bias~\cite{stevenson_sources_2013,brandt_mapping_2015}. Consequently, in the
last few years, the field has shifted first towards using sets of reference
sequences, and more recently to graph data structures (so-called {\em genome
graphs}), to represent many genomes or haplotypes
simultaneously~\cite{dilthey_improved_2015,paten_genome_2017,garrison_variation_2018}.

% Sequencing and variant calling
The analysis and understanding of genetic variation encoded in the genome of an
organism lies at the center of computational biology and medicine. Variation is
usually identified through matching sequences obtained from DNA/RNA-sequencing
back to a reference (genome) sequence in the process of \emph{variant calling},
making the alignment task a core problem in sequence bioinformatics.

\subsection{Global alignment}
% paper:seeds
%\subsection{Problem statement: Alignment as shortest path} \label{SEEDsec:task}
%

%\section{Task Description: Alignment to Reference Graphs}
\label{TRIEsec:task}

We now describe the task of aligning a query to a reference graph. To this end,
we (i)~introduce the task of optimal alignment on a \emph{reference graph}, and
(iii)~introduce an alternative formulation in terms of an \emph{alignment
graph}, which is the basis for shortest path formulations of the optimal
alignment.
%
\cref{TRIEfig:graph-constructions} summarizes these different graph types.

\paragraph{Reference graph}
We encode the collection of references to which we want to align in a reference
graph, which captures genomic variation that a linear reference cannot
express~\cite{paten_genome_2017,garrison_variation_2018}.
%
We formalize a reference graph as a tuple $\RG=(\RGV,\RGE)$ of nodes $\RGV$ and
directed, labeled edges $\RGE \subseteq \RGV \times \RGV \times \Sigma$, where
the alphabet $\Sigma=\{\texttt{A},\texttt{C},\texttt{G},\texttt{T}\}$ represents
the four different nucleotides.
%
Note that in contrast to sequence graphs~\cite{rautiainen_aligning_2017}, we
label edges instead of nodes.

\paragraph{Path, spelling}
Any path $\pi=(e_1,\dots,e_k) \text { in } \RG$ induces a \emph{spelling}
$\sigma(\pi) \in \Sigma^*$ defined by $\sigma(e_1)\cdots\sigma(e_k)$, where
$\sigma(e_i)$ is the label of edge $e_i$ and $\Sigma^* := \bigcup_{k \in
\mathbb{N}} \Sigma^k$. We note that our approach naturally handles cyclic walks
and does not require cycle unrolling, a feature of
\bitparallel~\cite{rautiainen_bitparallel_2019} but missing from
\vg~\cite{garrison_variation_2018}, \pasgal~\cite{jain_accelerating_2019} and
\valigntool~\cite{kavya_sequence_2019}.

\paragraph{Alignment on reference graph}
An \emph{alignment} of \emph{query} $q \in \Sigma^*$ to a reference graph
$\RG=(\RGV,\RGE)$ consists of (i)~a path $\pi \text{ in } \RG$ and (ii)~a
sequence of edit operations (matches, substitutions, insertions, deletions)
transforming $\sigma(\pi)$ to~$q$.

\paragraph{Optimal alignment, edit Distance}
Each edit operation is associated with a real-valued cost ($\cmatch$, $\csubst$,
$\cins$, and $\cdel$, respectively).
An optimal alignment minimizes the total cost of the edit operations converting
$\sigma(\pi)$ to $q$. For optimal alignments, this total cost is equal to the
edit distance between $\sigma(\pi)$ and $q$, \ie, the cheapest sequence of edit
operations transforming $\sigma(\pi)$ into $q$.

We make the (standard) assumption that $0 \leq \cmatch \leq \csubst, \cins,
\cdel$, which will be a prerequisite for the correctness of our approach.

\begin{figure}[t]
	\centering
	\includegraphics[width=0.8\columnwidth]{edit_graph}
	\caption[Constructing the alignment graph]{Starting from the reference graph
	(left), we can construct the edit graph (middle) and the alignment graph
	$\AG$ for query $q=``\texttt{A}"$ (right). Edges are annotated with labels
	and/or costs, where sets of labels represent multiple edges, one for each
	letter in the set (indicated by $``\text{x}3"$ and $``\text{x}4"$).}
	\label{TRIEfig:graph-constructions}
\end{figure}

% TODO: remove
%\paragraph{Edit graph}
%Instead of representing alignments as pairs of (i)~paths in the reference graph and
%(ii)~sequences of edit operations on these paths, we introduce \emph{edit
%graphs} whose paths intrinsically capture both. This way, we can
%formally define an alignment more conveniently as a path in an edit graph.
%
%Formally, an \emph{edit graph} $\EG:=(\EGV,\EGE)$ has directed, labeled edges
%$\EGE \subseteq \EGV \times \EGV \times \Sigma_\epsilon \times \mathbb{R}_{\geq
%0}$ with associated costs that account for edits. Here, $\Sigma_\epsilon :=
%\Sigma \cup \{\epsilon\}$ extends the alphabet $\Sigma$ by $\epsilon$ to account
%for deleted characters (see \cref{TRIEfig:graph-constructions}).
%%
%The edit and reference graphs consist
%of the same vertices, \ie, $\EGV=\RGV$. However, $\EGE$ contains more edges
%than $\RGE$ to account for edits.
%%
%Concretely, for each edge $(u,v,\ell) \in \RGE$, $\EGE$ contains edges to
%account for (i)~matches, by an edge $(u,v,\ell,\cmatch)$, (ii)~substitutions, by
%edges $(u,v,\ell',\csubst)$ for each $\ell' \in \Sigma \backslash \ell$,
%(iii)~deletions, by an edge $(u,v,\epsilon,\cdel)$, and (iv)~insertions, by
%edges $(u,u,\ell',\cins)$ for each $\ell' \in \Sigma$.
%%
%The spelling $\sigma(\pi) \in \Sigma^*$ of a path $\pi \in \EG$ is defined
%analogously to reference graphs, except that deleted letters (represented by
%$\epsilon$) are ignored. The cost $\cost{\pi}$ of a path $\pi \in \EG$ is the
%sum of all its edge costs.
%
%\paragraph{Alignment on edit Graph}
%An \emph{alignment} of query $q$ to $\RG$ is a path $\pi \text{ in } \EG$
%spelling $q$, \ie, $q=\sigma(\pi)$. An \emph{optimal alignment} is an alignment
%of minimal cost.

\paragraph{Alignment graph}
To find an optimal alignment of $q$ using shortest path finding algorithms, we
must ensure that only paths spelling $q$ are considered. To this end, we
introduce an alternative but equivalent formulation of alignments in terms of an
\emph{alignment graph} $\AG=(\AGV,\AGE)$.

Here, each \emph{state} $\langle v,i \rangle \in \AGV$ consists of a vertex $v \in
\RGV$ and a query position $i \in \{0,\dots,|q|\}$ (equivalent
to~\cite{rautiainen_aligning_2017}). Traversing a state $\langle v,i \rangle \in
\AGV$ represents the alignment of the first $i$ query characters ending at node $v$.
%
In particular, query position $i=0$ indicates that we have not yet matched any
letters from the query.
%
We note that the alignment graph explicitly depends on the query $q$. In
particular, the example alignment graph $\AG[``\texttt{A}"]$ in
~\cref{TRIEfig:graph-constructions} lacks substitution edges from $\AG$, as their
labels ($\texttt{C}$, $\texttt{G}$, $\texttt{T}$) do not match the query
$q=``A"$.

%We construct the alignment graph $\AG$ to guarantee that any walk from a source
%$\langle u,0 \rangle$ to a state $\langle v,i \rangle$ corresponds to an
%alignment of the first $i$ letters of query $q$ to $\RG$.
%As a consequence, there is a one-to-one correspondence between alignments $\edit{\pi}$ of $q$ to
%$\EG$ and paths $\alignment{\pi} \in \AG$ from sources $S:=\RGV \times \{0\}$ to
%targets $T:=\RGV \times \{|q|\}$, with
%$\cost{\reference{\pi}}=\cost{\alignment{\pi}}$. To find the best alignment in
%$\EG$, only paths in $\AG$ (walks without repeating nodes) can be considered,
%since repeating a node in $\AG$ cannot lead to a lower cost ($\cdel \geq 0$) for
%the same state.

%The edges $\AGE \subseteq \AGV \times \AGV \times \Sigma_\epsilon \times
%\mathbb{R}_{\geq 0}$ are built based on the edges in $\EGE$, except that the
%former (i)~keep track of the position in the query $i$, and (ii)~only contain
%empty edges or edges
%whose label matches the next query letter:

\vspace{-1.2em}
{%
\small
\begin{alignat}{10}
	(u,v,\ell,w) &\in \AGE \implies (&\langle u, i \rangle, &\langle v, i+1
		&&\rangle,\ell,w) \in \AGE \quad \text{ for } 0 \leq i < |q| \text{ with }
		q[i]=\ell \label{TRIEeq:alignment-edges-nondeletions} \\
	(u,v,\epsilon,w) &\in\AGE \implies (&\langle u, i \rangle, &\langle v, i
		&&\rangle,\epsilon,w) \in \AGE \quad \text{ for } 0 \leq i < |q| \label{TRIEeq:alignment-edges-deletions}
\end{alignat}
}%

Here, assuming $0$-indexing, $q[i]$ is the next letter to be matched after
matching $i$ letters. Then, \cref{TRIEeq:alignment-edges-nondeletions} represents
matches, substitutions, and insertions (which advance the position in the query
by $1$), while \cref{TRIEeq:alignment-edges-deletions} represents deletions (which do
not advance the position in the query).

\paragraph{Dynamic construction}
As the size of the alignment graph is $\Oh(\lvert \RG \rvert \concat \lvert q
\rvert)$, it is expensive to build it fully for every new query.
Therefore, our implementation constructs the alignment graph $\AG$ on-the-fly:
the outgoing edges of a node are only generated on demand and are freed from
memory after alignment.