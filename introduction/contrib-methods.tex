\subsection*{Methods}

\paragraph{\A for sequence alignment}
We consider the sequence alignment problem in its principled and powerful graph
formulation: an alignment minimizing edit distance is equivalent to a shortest
path in an \emph{alignment graph}. It allows to choose any shortest path
algorithm, and, assuming non-negative edit costs, we select the \A algorithm for
its ability to use any available information to quickly direct the search and
yet, to guarantee optimality. In order to efficiently apply \A to semi-global
and global alignment, we complement the reference with a trie index, design a
powerful \emph{seed heuristic}, and implement a number of algorithmic
optimizations.

\paragraph{Trie index for scaling with reference size}
In~\cref{ch:trie} we suggest how to exploit that many query sequences are
semi-globally aligned to the same reference. As a preprocessing step, we
complement the reference with a trie index so that any kmer from the reference
appears as a path from the trie root to a trie leaf, and then links to the
reference. This way, any substring in the trie is a spell of a path from the
trie root.

\paragraph{General graph references}
For semi-global alignment of many query sequences to the same reference

\paragraph{Seed heuristic for scaling with query length}
The seed heuristic To this end, we design an admissible heuristic function which
quickly and accurately estimates a lower bound on the remaining shortest path
(i.e. the edit distance to align the unaligned suffix of one of the sequences). 

For any explored state by \A, this heuristic function should compute a lower
bound on the remaining path length.

we introduce a novel
\emph{seed heuristic} to scale with sequence subquadratically with length, and
chaining to scale with error rate.
In addition to the trie index to scale with reference size, 
%
We borrow the existing concept of seeds but apply it in a novel way: instead of
finding alignments around seed matches, we use the lack of matches to penalize
alignments by desigining the \emph{seed heuristic} that drive the \A search.
%
We have effectively applied the \A algorithm to optimal sequence alignment. We
demontrate that the additional information from the whole sequence can improve
the scaling with query length, reference size and error rate, substantially
decrease the necessary computations, and result in algorithms that are orders of
magnitude faster than existing optimal algorithms. We apply the \A approach to
two types of alignment: semi-global (alignment) and global.

%\section{Reconceptualizing seeds for optimal alignment}
\paragraph{Beyond \emph{seed-(chain)-extend} paradigm}
%\addcontentsline{toc}{subsection}{\protect\numberline{}{Beyond \emph{seed-(chain)-extend} paradigm}}

As we saw in \cref{ch:trie,ch:seed}, all optimal read aligners compute the whole
dynamic programming table, thus reaching the prohibitively slow quadratic
runtime. On the other side, all current production aligners rely on the
\emph{seed-extend} paradigm (and its \emph{seed-chain-extend} variants for long
reads).
%
This paradigm requires similar short \emph{seed} patches to be found
between the sequences (\AG by hashed kmers, minimiziers, maximum exact matching,
etc.), and then to \emph{extend} the alignment of the whole query around these
\emph{seeded} similar patches. This is a very intuitiv approach if the goal is
to find a \emph{good alignment}.
%
If we instead seek not good but provably \emph{best} alignments, we are required
to at least implicitly refute all the exponentially-many competing alignments.
%
Instead, to find optimal alignments, we do not need to choose the seeds to be
long and similar with the reference buare not required to be similar.
%
\begin{observation}[Seeds without matches]
    To efficiently find an optimal alignment using \A with the seed heuristic,
    seeds are not required to match (even on the resulting alignment).
\end{observation}
%
Nevertheless, each seed can penalize potential alignment by not more than its
\emph{potential} (\ie the number of plus $1$, for the case of exact matching
with unit costs). Any additional errors will require more states to be expanded.
%
This is an interesting observation was made by Ragnar while playing with the
seed heursitic. It looks Indeed, of finding a good alignment but to prove that all
alternative alignments are no better, the seed heuristic for \A search does not
really need matches to be efficient.
%
This novel usage of seeds carrie different problems and different possibilities.

\paragraph{Optimality guarantees}
To ensure that our algorithms are practical, we introduce a number of
algorithmic optimizations which increase performance and decrease memory
footprint.
%
We also prove that all optimizations (greedy matching, ) are preserving the optimality.

\paragraph{Implementations}




%%%%%%
As it turns out, when the error rate is limited, our optimal solutions
empirically scale near-linearly up to very long sequences. This translates to
many orders of magnitude of runtime speedup compared to state-of-the-art optimal
aligners.


In contrast, here we demonstrate that seeds can benefit optimal alignment as
well.

In contrast, we follow the promising direction of using a heuristic to avoid
worst-case runtime on realistic data. To this end, \astarix rephrases the task
of alignment as a shortest-path problem in an \emph{alignment graph} extended by
a \emph{trie index}, and solves it using the \A~algorithm instantiated with a
problem-specific \prefixh. Importantly, its choice of heuristic only affects
performance, not optimality.
%
Unlike DP-based algorithms, this \prefixh allows scaling sublinearly with the
reference size, substantially increasing performance on large genomes. However,
it can only efficiently align reads of limited length.

Most of the techniques this thesis builds upon have been known for many decades
and have also been heavily motivated by applications in molecular biology. 

The specifics with semi-global alignment requires a trie-like index which is
well-used in the fields, and known since
\citeyear{thue1912gegenseitige}~\cite{thue1912gegenseitige} and used in
informatics since~\citeyear{de1959file}~\cite{de1959file}.