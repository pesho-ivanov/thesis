\subsection*{Methods}

\paragraph{\A for sequence alignment}
We consider the sequence alignment problem in its principled and powerful graph
formulation: an alignment minimizing edit distance is equivalent to a shortest
path in an \emph{alignment graph}. It allows to choose any shortest path
algorithm, and, assuming non-negative edit costs, we select the \A algorithm for
its ability to use any available information to quickly direct the search and
yet, to guarantee optimality. In order to efficiently apply \A to semi-global
and global alignment, we complement the reference with a trie index, design a
powerful \emph{seed heuristic}, and implement a number of algorithmic
optimizations. We formally prove the optimality of all algorithms, data
structures, and optimizations.

\paragraph{Implicit constructiong of the alignment graph}
The alignment graph is defined as a Cartesian product of the reference and the
query. The structure of the alignment graph is thus regular, and we do not have
to build it explicitly but to only constuct it locally at the node we are
exploring. This optimization is crucial for the overall performance of \A which
spends time only at explored nodes before terminating at the target.

\paragraph{Sequence-to-graph alignment}
Unlike most dynamic programming solutions, we are not bound to acyclic graphs
due to using the general \A shortest path algorithm. Thus, our reference is not
limited to being a linear sequence but can as well be any genome graph. All
semi-global alignment algorithms in this thesis are applicable to general graphs
(possibly including cycles).

\paragraph{Scaling with reference size using a trie index}
In~\cref{ch:trie} we suggest how to exploit that many query sequences are
semi-globally aligned to the same reference. As a preprocessing step, we
complement the reference with a trie index (similar to a suffix tree) so that
any kmer from the reference appears as a path from the trie root to a trie leaf,
and then links to the reference. This way, any substring in the trie is a spell
of a path from the trie root. With an accurate heuristic function (i.e.
estimating the remaining edit distance well), this trie complement allows to
ignore most of the reference.

\paragraph{Scaling with query length using seed heuristic}
In~\cref{ch:seed} we introduce a powerful \emph{seed heuristic} for \A. It
estimates the remaining edit distance based on information from the whole
reference and query, we prove its admissibility, and present an algorithm for
its efficient computation.

In order to quickly compute the seed heuristic for any explored state by \A, we
first precompute.

We borrow the existing concept of seeds but apply it in a novel way: instead of
finding alignments around seed matches, we use the lack of matches to penalize
alignments by desigining the \emph{seed heuristic} that drive the \A search.

In addition to the trie index to scale with reference size, 

To ensure that our algorithms are practical, we introduce a number of
algorithmic optimizations which increase performance and decrease memory
footprint.

Negation

\paragraph{Scaling with error rate using chaining, inexact matching and gap costs}
In~\cref{ch:global} we. The specifics with semi-global alignment requires a
trie-like index which is well-used in the fields, and known since
\citeyear{thue1912gegenseitige}~\cite{thue1912gegenseitige} and used in
informatics since~\citeyear{de1959file}~\cite{de1959file}.

\paragraph{Optimizations} Greedy matching

\paragraph{Implementations}
\astarix\footnote{\url{https://github.com/eth-sri/astarix}} and \astarpa\footnote{\url{https://github.com/RagnarGrootKoerkamp/astar-pairwise-aligner}}, minSH

MinSH\footnote{\url{https://github.com/pesho-ivanov/minSH}}: Minimalistic Python
implementation of the seed heuristic for global alignment.

\begin{minted}[fontsize=\footnotesize, frame=lines]{python}
def build_seedh(A, B, k):
    seeds = [ A[i:i+k] for i in range(0, len(A)-k+1, k) ]
    kmers = { B[j:j+k] for j in range(len(B)-k+1) }
    is_seed_missing = [ s not in kmers for s in seeds ]
    suffix_sum = np.cumsum(is_seed_missing[::-1])[::-1]
    return lambda ij, k=k: suffix_sum[ ceildiv(ij[0], k) ]

h_seed = build_seed_heuristic(A, B, k=log(len(A)))
astar(A, B, h_seed)
\end{minted}